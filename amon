#!/bin/bash
#############################################################################
# amon - a script to monitor an manage AliEn services
#
# modification history
# $Log$
# Revision 1.1  2007/02/15 12:56:43  pbuncic
# Initial revision
#
# Revision 1.1  2007/02/09 11:12:55  pbuncic
# Initial revision
#
#
# SYNOPSIS
# amon [flags] <command [options]>
#
# DESCRIPTION
#
# AUTHOR:
# Predrag Buncic, e-mail: Predrag.Buncic@cern.ch
#
# CREATION DATE:
# 07-Feb-2007
###########################################################################
CONFIG_SITEVARS="ALIEN_ORGANISATION ALIEN_ROOT ALIEN_LOGDIR ALIEN_CS_LOGDIR ALIEN_PLATFORM ALIEN_COMPONENTS ALIEN_SERVICES ALIEN_INSTALLED_SERVICES LOGFILES PERL AMON_SITE_TOKEN"
#############################################################################
amonModules() {
#############################################################################
    cat<<EOF
9208a1a9ddecab3152e00b72569f1793  libxml2-2.6.27.tar.gz
1d1b1d5c0245b1c00aff92da751e9aa1  gdbm-1.8.3.tar.gz
b8c118d4360846829beb30b02a6b91a7  perl-5.8.8.tar.gz
bcbaab776a54d1e34e3a057c925de9ca  monit-4.9.tar.gz
8b3d9cf3eadebdfbe5847d80ed3a2d0b  Module-Build-0.28.tar.gz
9c84640123eea12cfc58c6b5e7060ad8  Storable-2.15.tar.gz
1a933b1114c41a25587ee59ba8376f7c  URI-1.35.tar.gz
2e6a976cfa5521e815c1fdf4006982de  IO-stringy-2.110.tar.gz
3c986323dd4f3160187905d57cb660f0  Log-TraceMessages-1.1.tar.gz
8b6ed8da4fc0f50b84da8d862dfd4a8e  Log-Log4perl-1.11.tar.gz
5051d6743d96781c677bd6ffeae5e0e9  Digest-SHA1-2.02.tar.gz
32dc54c765100c638b5d7f7ff4c5c626  Digest-HMAC-1.01.tar.gz
041ce912640c5dff626a91435a359b88  Authen-SASL-2.10.tar.gz
29a89f3e46cbb3fc2c24507f91a0a843  Time-HiRes-1.94.tar.gz
fc1b182880d74d82938e1210923cb6c5  MIME-Base64-2.16.tar.gz
db2b3b2e608df569a925986b04182ea2  PathTools-3.23.tar.gz
20b5a6894762d9eda7ba631515f8bbb3  File-Spec-0.88.tar.gz
b0cd6c1681bbc0695d81be5cd852d1d0  Net_SSLeay.pm-1.30.tar.gz
34562e9475de132faa0f14ca2be053a5  IO-Socket-SSL-0.97.tar.gz
b0867d7b599d8a63ba630fa6227936fe  XML-NamespaceSupport-1.09.tar.gz
84d9e0001fe01c14867256c3fe115899  XML-Parser-2.34.tar.gz
4b2276bafedc5a41cf50fea2296e31c4  XML-SAX-0.15.tar.gz
80c0980ff63d77b871de41acc7175df7  XML-Simple-2.16.tar.gz
a31400a29eae0eec74650bd06dbc823f  XML-SAX-Expat-0.39.tar.gz
073448591f374103a124a4a2b26992a5  XML-SAX-Expat-Incremental-0.04.tar.gz
13b6d93f53375d15fd11922216249659  XML-LibXML-Common-0.13.tar.gz
750e296f57a6e245caf4829a25440cef  XML-LibXML-1.63.tar.gz
ceb711a723464b6132fec8ee58a393f0  Net-DNS-0.42.tar.gz
90298105cd17a5c2a4059297e09f1546  Net-Netmask-1.9015.tar.gz
b3107452e2bb4d74d4b9892d61d50137  perl-ldap-0.31.tar.gz
c2ac1379ac5848dd32e24347cd679391  HTML-Parser-3.45.tar.gz
db1eb693eee45d251966ad2bab49dbbf  libwww-perl-5.805.tar.gz
b5e76be5dfb90d8c8fdb8c28b2f9a427  Convert-ASN1-0.17.tar.gz
1a52e65a9459e4deafd5b2fdf932d0ba  Convert-UU-0.52.tar.gz
d87b05143c6c2bc9464758e68e9c6e25  libevent-1.3.tar.gz
9b241bc4a482a3aa59fbb1429bc30546  String-CRC32-1.4.tar.gz
6ff64fb974d131fdb7f9d5fdf955dc9a  memcached-1.2.1.tar.gz
e416057d3b1273e6d2a0ac465fb0e3bd  Cache-Memcached-1.14.tar.gz
a29b1ddd6fea9f7e11f0f82534d4204c  Sys-Syscall-0.22.tar.gz
094386c6ada4d8f4be40691897061f79  Danga-Socket-1.57.tar.gz
33632a41f7560801ca57802fe1f44667  Gearman-1.07.tar.gz
2fcd67f8fec8f011d30c0a956667cdc3  Gearman-Server-1.08.tar.gz
dfa9b5435c2d0539aa023fed7dde9122  Gearman-Client-Async-0.93.tar.gz
6ba7fe0745242c33dfb8860e8fee222e  IO-AIO-2.33.tar.gz
cd577c43ecc30b7cbb5b46ead97bb6bc  Perlbal-1.57.tar.gz
12d60ac4c4732361e2ca363a67a74a08  mogilefs-server-2.15.tar.gz
e53f76c7db26c7f8ac0628d3e35de1b2  MogileFS-Client-1.07.tar.gz
57208ef6dccb3e72cf2df665983ce313  DBI-1.52.tar.gz
7f22d8789245047343e114e655571022  DBD-SQLite-1.11.tar.gz
ce449b6ef429eb65ec03be4c8d19b1aa  DJabberd-0.83.tar.gz
6b8e666ab55e1e2bc455bdce5e6f4e42  DJabberd-RosterStorage-SQLite-1.00.tar.gz
cb586eee8afc8618636e8cac19d73456  DJabberd-Authen-LDAP-0.01.tar.gz
3b6034c977565504a8429f6d7b56a20e  DJabberd-Authen-SiteToken-0.01.tar.gz
15aa7b46d94c2dcd9fe0acc8914943df  Filter-Template-1.02.tar.gz
a1d67de6baa4afe4def3ea847da71755  POE-0.9917.tar.gz
fab1ddd3e307b4ce3890a4708cfd04de  POE-Component-Client-Keepalive-0.0901.tar.gz
3cafec48ed997ecb97cb980ef82732b8  POE-Component-Client-DNS-1.00.tar.gz
d0bcb39e2eee75200da2e622b4f2bb69  POE-Component-Client-HTTP-0.81.tar.gz
afd22e2e247c9c1be63c57caef4d6be9  POE-Component-Server-PreforkTCP-0.11.tar.gz
20bda6f76eacf1d1d4ecb02f922c99f7  POE-Component-SSLify-0.06.tar.gz
35827260ad62e9d1bcbf74ada943deb9  POE-Component-Child-1.39.tar.gz
f7e5c55808be528db02753f037c858d4  POE-Filter-XML-0.33.tar.gz
fb855be29a8a2ca2626f7eb7640a1d05  POE-Component-Jabber-2.01.tar.gz
EOF
}
#############################################################################
buildOptions() {
#############################################################################
    export PREFIX=$AMON_HOME
    CONFIGURE_CMD="$PREFIX/bin/perl Makefile.PL" 
    CONFIGURE_ARG="PREFIX=$PREFIX"
    CONFIGURE_ENV=""
    CONFIGURE_INPUT=""
    CONFIGURE_ENV="PERL_MM_USE_DEFAULT=1"
    BUILD_CMD="make"
    BUILD_ARG=""
    INSTALL_CMD="make"
    INSTALL_ARG="install"
  
    case $1 in
      GPG*)
        ;;
      perl-ldap-*)
        ;;
      perl-*)
        CONFIGURE_CMD="./Configure"
        CONFIGURE_ARG="-d -des -Dinstalldirs=perl  -Doptimize=-O -Dccflags=-fPIC -Dinstallprefix=$PREFIX -Dprefix=$PREFIX -Dd_semctl_semun -Di_db -Di_syslog -Dudsedl=yes -Dman3ext=3 -Dusemymalloc=no -DDEBUGGING -Dplibpth=$PREFIX/lib -Dldflags=-L$PREFIX/lib -A append:libswanted= pthread"
        ;;
      monit*|libevent-*|memcached-*|gdbm-*)
        CONFIGURE_CMD="./configure"
        CONFIGURE_ARG="--prefix=$PREFIX"
        ;;
      libxml2-*)
        CONFIGURE_CMD="./configure"
        CONFIGURE_ARG="--prefix=$PREFIX --without-python"
        ;;
      libxslt-*)
        CONFIGURE_CMD="./configure"
        CONFIGURE_ARG="--prefix=$PREFIX --with-libxml-prefix=$PREFIX --without-crypto"
        ;;
      expat-*)
        CONFIGURE_CMD="./configure"
        CONFIGURE_ARG="--prefix=$PREFIX --mandir=$(PREFIX)/man"
        ;;
      Module-Build-*)
        CONFIGURE_CMD="$PREFIX/bin/perl Build.PL"
        BUILD_CMD="./Build"
        INSTALL_CMD="./Build"
        ;;
      XML-SAX-[0-9]*)
        CONFIGURE_INPUT="n" 
        CONFIGURE_ENV="PERL_MM_USE_DEFAULT=0"
        ;;
      XML-LibXML-*)
        CONFIGURE_ENV="XMLPREFIX=$PREFIX"
        BUILD_ARG="LD_RUN_PATH="
        ;;
      XML-Parser*)
        CONFIGURE_ARG="EXPATLIBPATH=$PREFIX/lib EXPATINCPATH=$PREFIX/include"
        ;;
      Net_SSLeay.pm*)
        CONFIGURE_ARG="-- PREFIX=$PREFIX"
        ;;
      POE-Filter-XML-*|POE-Component-Jabber-*)
        CONFIGURE_CMD="$PREFIX/bin/perl Build.PL"
        BUILD_CMD="./Build"
        INSTALL_CMD="./Build"
        ;;
      POE-[0-9]*)
        CONFIGURE_ARG="PREFIX=$PREFIX --default"
        ;; 
      libwww-perl*)
        CONFIGURE_ARG="PREFIX=$PREFIX -n"
        ;; 
      Time-HiRes-*)
        export LC_ALL="C"
        ;; 
      *)
      ;;
    esac
}
#############################################################################
configPlatform() {
#############################################################################

   if [ "x$ALIEN_PLATFORM" = "x" ]
   then
      TMPDIR=`mktemp -d -q /tmp/amon.XXXXXX`
      for dir in /usr/share/libtool /usr/share/automake /usr/lib/rpm
      do
        if [ -x $dir/config.guess ]
        then
           platform=`$dir/config.guess`
           break
        fi
      done
      case $platform in
        i*86-*-linux-gnu)
          platform=i686-pc-linux-gnu
        ;;
        x86_64-*-linux-gnu)
          platform=x86_64-unknown-linux-gnu
        ;;
        powerpc-apple-darwin8.*)
          platform=powerpc-apple-darwin8.1.0
        ;;
        i686-apple-darwin8.*)
          platform=i686-apple-darwin8.6.1
        ;;  
        ia64-*-linux-gnu)
          platform=ia64-unknown-linux-gnu
        ;;
       *)
        ;;
      esac
      ALIEN_PLATFORM=$platform
    fi
    echo $ALIEN_PLATFORM
}


#############################################################################
configSiteToken() {
#############################################################################
     if [ x$ALIEN_UUID = x ] 
     then
       echo ""
     else
       echo $ALIEN_UUID | sha1sum | awk '{print $1}'
     fi
} 
 
#############################################################################
configGuess() {
#############################################################################
    if  [ -r $HOME/.alien/etc/aliend/startup.conf ] 
    then
      . $HOME/.alien/etc/aliend/startup.conf
    fi
    
    if [ -z $ALIEN_ORGANISATION ]
    then
      ALIEN_ORGANISATION=ALICE
    fi 

    var=VO_${ALIEN_ORGANISATION}_SW_DIR
 
    if [ "x${!var}" != x  ]
    then
       ALIEN_ROOT=${!var}/alien
       if [ "x$ALIEN_COMPONENTS" = x ]
       then
         ALIEN_COMPONENTS="gshell lcg site monitor"
       fi 
    fi 

    if [ -r $HOME/.alien/etc/aliend/$ALIEN_ORGANISATION/startup.conf ]
    then
      source $HOME/.alien/etc/aliend/$ALIEN_ORGANISATION/startup.conf
    fi
   
    if [ -r $HOME/.alien/alice.conf -a "x$ALIEN_LOGDIR" = x ] 
    then
      ALIEN_LOGDIR=`cat $HOME/.alien/alice.conf | grep LOG_DIR | awk "{ print \\\$2}"`
    fi
    
    if [ -d $HOME/.alien/var/log/AliEn/$ALIEN_ORGANISATION ]
    then
      ALIEN_CS_LOGDIR=${ALIEN_CS_LOGDIR:-$HOME/.alien/var/log/AliEn/$ALIEN_ORGANISATION}
    fi
    
    ALIEN_PLATFORM=`configPlatform`

    if [ "x$ALIEN_PLATFORM" = "x" ]
    then
        echo "Could not guess your platform. Please set ALIEN_PLATFORM variable"
        exit
    fi
    
    ALIEN_CONFIG_SERVER=${ALIEN_CONFIG_SERVER:=alien.cern.ch}
    
    if  [ -r $HOME/.alien/Environment ] 
    then
      . $HOME/.alien/Environment
    fi

    if [ ! -r $AMON_HOME/default.conf ]
    then
      wget -O -  "http://$ALIEN_CONFIG_SERVER/bin/alien-config?platform=$ALIEN_PLATFORM&organisation=$ALIEN_ORGANISATION&id=$ALIEN_USER" > \
                 $AMON_HOME/default.conf 2> /dev/null
      chmod 600 $AMON_HOME/default.conf   
    fi
    
    AMON_SITE_TOKEN=`configSiteToken`; export AMON_SITE_TOKEN

    if [ -x $AMON_HOME/bin/perl ] 
    then
       PERL=$AMON_HOME/bin/perl
    else
       PERL=perl
    fi

    configSite
  
    installCrontab 
}

#############################################################################
configEnv() {
#############################################################################

    export AMON_HOME=$HOME/.alien/amon
    base=`basename $0`
    case $0 in
       ./*)
       dir=$PWD
       ;;
         *)
       dir=`dirname $0`
       ;;
    esac
    export AMON=$dir/$base

    if [ ! -f $AMON_HOME/checksum ] 
    then
      buildModules || exit 1
    fi
    
    csum=`amonModules | md5sum`
    osum=`cat $AMON_HOME/checksum`
    
    if [ "$csum" != "$osum" ]
    then
      buildModules || exit 1
    fi
    
    export PERL5LIB=$AMON_HOME:$AMON_HOME/lib64/perl5/site_perl:$AMON_HOME/lib64/perl5:$AMON_HOME/lib/perl5/site_perl:$AMON_HOME/lib/perl5:$AMON_HOME/share/perl:$AMON_HOME/lib/perl
    export LD_LIBRARY_PATH=$AMON_HOME/lib:$LD_LIBRARY_PATH
    export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH
    
    mkdir -p $AMON_HOME
    
    if [ -r $AMON_HOME/custom.conf ] 
    then
      . $AMON_HOME/$custom.conf
    fi
    
    for file in default site keys
    do 
      if [ -f $AMON_HOME/$file.conf ]
      then
        eval `cat $AMON_HOME/$file.conf | sed -n -e '/^[^+]/s/\([^=]*\)[=]\(.*\)/\1="\2"; export \1;/gp'`
      fi 
    done 

    lcgvar=VO_${ALIEN_ORGANISATION}_SW_DIR

    if [ "x${!lcgvar}" = "x" ]
    then
      export ALIEN_LCG=0  
    else
      export ALIEN_LCG=1
    fi
}

#############################################################################
reBuildModules() {
#############################################################################

    export AMON_HOME=$HOME/.alien/amon
    base=`basename $0`
    case $0 in
       ./*)
       dir=$PWD
       ;;
         *)
       dir=`dirname $0`
       ;;
    esac
    export AMON=$dir/$base

    BUILD_FROM_SOURCE=true

    buildModules || exit 1
}


#############################################################################
amonCrontab() {
#############################################################################
    echo "SHELL=/bin/bash"
    echo "USER=$USER"
    echo "HOME=$HOME"
    crontab -l | grep "^.* .* .* .* .*" | grep -v $AMON
    cat<<EOF
0,15,30,45 * * * * $AMON --monit > /tmp/amon.log 2>&1
EOF
}

#############################################################################
installCrontab() {
#############################################################################
   crontab -l | grep -c $AMON > /dev/null 2>&1 || amonCrontab | crontab
}

#############################################################################
buildLog () {
#############################################################################
    if [ $1 -eq 0 ]
    then
      printf "OK.\n"
    else
      printf "FAILED.\n"
      printf "=======================================================================\n"
      printf "                        $2 log\n"
      printf "=======================================================================\n"
      [ -f "$TMPDIR/amon.log" ] && cat $TMPDIR/amon.log
      printf "=======================================================================\n"
      exit 1
    fi
}

#############################################################################
buildModules() {
#############################################################################
    AMON_HOME=$HOME/.alien/amon
    BUILD_ENV="PERL5LIB=$AMON_HOME/lib/perl5:$AMON_HOME/lib/perl5/site_perl"
    RUN_ENV="LD_LIBRARY_PATH=$AMON_HOME/lib DYLD_LIBRARY_PATH=$AMON_HOME/lib"
    platform=`configPlatform`
    BINMODULES="amon-$platform"
    MODULES=`amonModules | awk '{print $2}' | awk -F'.tar.gz' '{print $1}'`
    TEST=0
    
    WGETOPTS="-N --waitretry=10 --tries=3"
    
    URL=http://alien.cern.ch/cache/
    
    TMPDIR=`mktemp -d -q /tmp/amon.XXXXXX`
    
    mkdir -p $TMPDIR
     
    if [ $? -ne 0 ]; 
    then
        echo "$AMON: Cannot create temp file, exiting..."
        exit 1
    fi
    
    (
    cd $TMPDIR
    
    printf "Downloading components...."
    
    PERL=$AMON_HOME/bin/perl

    for module in $MODULES
    do
      wget $WGETOPTS -P . $URL/$module.tar.gz
      rc=$?
      if [ $rc -ne 0 ] 
      then
         break
      fi 
    done > $TMPDIR/amon.log 2>&1          
    
#    buildLog $rc $module 
    
    printf "Verifying checksums...."
    
    amonModules | md5sum -c - >> $TMPDIR/amon.log 2>&1 || exit 1 
    
#    buildLog $? $module 
    
    for module in $BINMODULES
    do
      wget $WGETOPTS -P . $URL/$module.tar.gz
      rc=$?
      if [ $rc -ne 0 ] 
      then
         break
      fi 
      printf "Building binary $module...."
      (dir=`dirname $AMON_HOME`; tar zxf $module.tar.gz -C  $dir)  >> $TMPDIR/amon.log 2>&1
      if [ $? -eq 0 ] 
      then
        exit 0 
      fi
    done >> $TMPDIR/amon.log 2>&1          

    for module in $MODULES
    do
        printf "Building $module...."
        ( buildOptions $module;  tar zxvf $module.tar.gz && \
          cd $module &&  \
          echo $CONFIGURE_INPUT | \
          env $CONFIGURE_ENV $RUN_ENV $CONFIGURE_CMD $CONFIGURE_ARG && \
          env $BUILD_ENV $RUN_ENV $BUILD_CMD $BUILD_ARG && \
          env $BUILD_ENV $RUN_ENV $INSTALL_ENV $INSTALL_CMD $INSTALL_ARG
        )  > $TMPDIR/amon.log 2>&1
        buildLog $? $module
    done 

    )
    
    if [ $? -eq 0 ]
    then
      amonModules | md5sum > $AMON_HOME/checksum
    fi  
    
    rm -rf $TMPDIR
    unset TMPDIR 
}

#############################################################################
monitHeader() {
#############################################################################
  LOGFILES=""
  cat<<EOF >$AMON_HOME/$HOSTNAME.monitrc
# Global monit run control configuration
set daemon 30

set pidfile ${ALIEN_LOGDIR}/monit.pid
set logfile ${ALIEN_LOGDIR}/monit.log
set statefile ${ALIEN_LOGDIR}/monit.state

set httpd port 2812
      ssl disable
      pemfile  $AMON_HOME/monit.pem
      clientpemfile $AMON_HOME/monit-clients.pem 
      allowselfcertification
      address localhost
      allow admin:$ALIEN_UUID

check file Environment with path $HOME/.alien/Environment
       if changed checksum then exec "$AMON --monit restart all"
       every 2 cycles

check process amon with pidfile "$AMON_HOME/amon.pid"
        alert ${ALIEN_NOTIFY_EMAIL}
        start "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON_HOME/restart"
        stop  "/bin/env kill \`cat $AMON_HOME/amon.pid\`"

EOF
}

#############################################################################
monitCentralService() {
#############################################################################
    if [ -z $ALIEN_CS_LOGDIR ] 
    then
      echo "Please define ALIEN_CS_LOGDIR variable or use --cs-logdir switch"
      exit
    fi 
    SERVICE_NAME=`echo $1 | awk -F= '{print $1}'`
    SERVICE_LOG=`echo $1  | awk -F= '{print $2}'`
    LOGFILES="$LOGFILES ${ALIEN_LOGDIR}/${SERVICE_LOG}.log"   

    LCGVAR=VO_${ALIEN_ORGANISATION}_SW_DIR

    cat<<EOF>>$AMON_HOME/$HOSTNAME.monitrc

check process $SERVICE_NAME with pidfile "${ALIEN_CS_LOGDIR}/${SERVICE_LOG}.pid"
        alert ${ALIEN_NOTIFY_EMAIL}
        start "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Start ${SERVICE_NAME}"
        stop  "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Stop ${SERVICE_NAME}"
        if children > 1000 then
                restart
        if cpu > 90% for 5 cycles then
                restart
        if totalmem > 2 GB then
                restart
EOF
}

#############################################################################
monitSiteService() {
#############################################################################
    SERVICE_NAME=`echo $1 | awk -F= '{print $1}'`
    SERVICE_LOG=`echo $1  | awk -F= '{print $2}'`
    LOGFILES="$LOGFILES ${ALIEN_LOGDIR}/${SERVICE_LOG}.log"   

    LCGVAR=VO_${ALIEN_ORGANISATION}_SW_DIR

    cat<<EOF>>$AMON_HOME/$HOSTNAME.monitrc

# AliEn ${SERVICE_NAME} monit run control file
check process ${SERVICE_NAME} with pidfile "${ALIEN_LOGDIR}/${SERVICE_LOG}.pid"
        alert ${ALIEN_NOTIFY_EMAIL}
        start "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Start ${SERVICE_NAME}"
        stop  "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Stop ${SERVICE_NAME}"
        if children > 1000 then
                restart
        if cpu > 90% for 5 cycles then
                restart
        if totalmem > 2 GB then
                restart
EOF
}

#############################################################################
monitProxy() {
#############################################################################
    if [ -z $ALIEN_CS_LOGDIR ] 
    then
      echo "Please define ALIEN_CS_LOGDIR variable or use --cs-logdir switch"
      exit
    fi 
    SERVICE_NAME=$1
    LOGFILES="$LOGFILES ${ALIEN_LOGDIR}/ProxyServer.log"   
    
    LCGVAR=VO_${ALIEN_ORGANISATION}_SW_DIR

    cat<<EOF>>$AMON_HOME/$HOSTNAME.monitrc

# AliEn Proxy Server monit run control configuration
check process Proxy with pidfile "${ALIEN_CS_LOGDIR}/ProxyServer.pid"
        alert ${ALIEN_NOTIFY_EMAIL}
        start program "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Start Proxy"
        stop  program "/bin/env HOME=$HOME AMON_HOME=$AMON_HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Stop Proxy"
        if children > 2000 then
                restart
        if cpu > 90% for 5 cycles then
                restart
        if totalmem > 2 GB then
                restart
EOF
}

#############################################################################
monitMonALISA() {
#############################################################################
    SERVICE_NAME=$1
    LOGFILES="$LOGFILES ${ALIEN_LOGDIR}/MonaLisa.log"   

    LCGVAR=VO_${ALIEN_ORGANISATION}_SW_DIR

    cat<<EOF>>$AMON_HOME/$HOSTNAME.monitrc

# MonALISA monit run control configuration
check process MonaLisa with pidfile "${ALIEN_LOGDIR}/MonaLisa.pid"
        alert ${ALIEN_NOTIFY_EMAIL}
        start "/bin/env USER=$USER AMON_HOME=$AMON_HOME HOME=$HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Start MonaLisa"
        stop  "/bin/env USER=$USER AMON_HOME=$AMON_HOME HOME=$HOME ALIEN_ORGANISATION=$ALIEN_ORGANISATION $LCGVAR=${!LCGVAR} $AMON --ctrl Stop MonaLisa"
        depends on MonaLisa_log0
        depends on MonaLisa_log
check file MonaLisa_log0 with path ${ALIEN_LOGDIR}/MonaLisa/ML0.log
        alert ${ALIEN_NOTIFY_EMAIL}
        if match "OutOfMemory" then restart
check file MonaLisa_log with path ${ALIEN_LOGDIR}/MonaLisa/ML.log
        alert ${ALIEN_NOTIFY_EMAIL}
        if match "OutOfMemory" then restart
EOF
}


#############################################################################
amonConfig() {
#############################################################################
    local services=""
      
    rm -f $AMON_HOME/default.conf

    configGuess

    configEnv
 
    LOGFILES=""  
  
    if [ -z $ALIEN_ROOT ] 
    then
        echo "Please define ALIEN_ROOT variable or use --alien-root switch"
        exit
    fi 
    if [ -z $ALIEN_LOGDIR ] 
    then
      echo "Please define ALIEN_LOGDIR variable or use --logdir switch"
      exit
    fi 
    
    if [ "x$ALIEN_COMPONENTS" = x ]
    then
      echo "Could not guess ALIEN_COMPONENTS. Please set ALIEN_COMPONENTS variable or use --alien-components option."
      exit
    fi

    if [ -z $ALIEN_NOTIFY_EMAIL ]
    then
      echo "Could not guess whom to notify. Please set ALIEN_NOTIFY_EMAIL variable or use --notify option."
      exit
    fi

    if [ -z $ALIEN_BITS_URL ]
    then
      echo "Could not guess BITS server. Please set ALIEN_BITS_URL variable or use --bits-url option."
      exit
    fi
    
    mkdir -p $ALIEN_LOGDIR/monit

    portal_services="httpd"    
    site_services="Monitor PackMan CE SE MonaLisa"
    core_services="Proxy IS Authen Server Logger TransferManager Broker TransferBroker TransferOptimizer JobOptimizer CatalogueOptimizer"

    for component in $(echo $ALIEN_COMPONENTS | sed 's/,/ /g')
    do
      case $component in
        site|Site)
          shift 1
          services="$services $site_services"
          ;;
        core|Core|Central|central)
          shift 1 
          services="$services $core_services"
          ;;
        xrootd)
          shift 1 
          services="$services xrootd"
          ;;
        monitor|Monitor)
          shift 1 
          services="$services MonaLisa"
          ;;
        portal)
          shift 1 
          services=" $services $portal_services"
          ;;
        all)
          shift 1 
          services="$services $site_services $core_services"
          ;;
         *) 
          shift 1
          ;;
       esac
    done
 
    ALIEN_INSTALLED_SERVICES=""

    for service in `echo $services | sed 's/ /\n/g' | sort -u`
    do
      ALIEN_INSTALLED_SERVICES="$ALIEN_INSTALLED_SERVICES $service"
    done
    if [ "x$ALIEN_SERVICES" = "x" ]
    then
      ALIEN_SERVICES=$ALIEN_INSTALLED_SERVICES
    fi 

    if [ "$ALIEN_SERVICES" = none ]
    then
      ALIEN_SERVICES=""
    fi

    if [ -f $AMON_HOME/$HOSTNAME.monitrc+ ]
    then
       cp -f $AMON_HOME/$HOSTNAME.monitrc+ $AMON_HOME/$HOSTNAME.monitrc
    else 
      monitHeader
  
      for service in $ALIEN_SERVICES
      do
        case $service in
          IS|Authen|Logger)
            monitCentralService "$service=$service"
            ;;
          SE|PackMan|CE|FTD|ApiService)
            monitSiteService "$service=$service"
            ;;
          MonaLisa)
            monitMonALISA "$service=$service"
            ;;
          Proxy)
            monitProxy "Proxy=ProxyServer"
            ;;
          Server|JobManager)
            monitProxy "Server=Manager::Job"
            ;;
          TransferManager)
            monitCentralService "TransferManager=Manager::Transfer"
            ;;
          Broker)
            monitCentralService "Broker=Broker::Job"
            ;;
          TransferBroker)
            monitCentralService "TransferBroker=Broker::Transfer"
            ;;
          TransferOptimizer)
            monitCentralService "TransferOptimizer=Optimizer::Transfer"
            ;;
          JobOptimizer)
            monitCentralService "JobOptimizer=Optimizer::Job"
            ;;
          CatalogueOptimizer)
            monitCentralService "CatalogueOptimizer=Optimizer::Catalogue"
            ;;
          Monitor)
            monitSiteService "Monitor=ClusterMonitor"
            ;;
          httpd|xrootd)
            ;;
          *)
          echo "Unsupported configuration type: $1"
          exit 1
        ;;
        esac
        shift 1
      done
  
      if [ -f $AMON_HOME/$HOSTNAME.monitrc ]
      then
        chmod 600 $AMON_HOME/$HOSTNAME.monitrc 
      fi
      configSite
    fi
 

}

#############################################################################
configSite() {
#############################################################################
    rm -f $AMON_HOME/site.conf
  
    if [ -f $AMON_HOME/site.conf+ ]
    then
      cp -f $AMON_HOME/site.conf+ $AMON_HOME/site.conf
    else
      for var in $CONFIG_SITEVARS
      do
        echo "$var=${!var}" >>  $AMON_HOME/site.conf
      done
    fi
    chmod 600 $AMON_HOME/site.conf  
}


#############################################################################
amonLCG() {
#############################################################################
    for file in globus.sh edg.sh lcg.sh lcgenv.sh gliteenv.sh z_edg-profile.sh z_lcg-profile.sh
    do
      [ -f /etc/profile.d/$file ] && . /etc/profile.d/$file
    done

    uid=${ALIEN_SERVICE_USER:=$USER}
    dn=${ALIEN_SERVICE_USER_DN}

    proxy=`vobox-proxy --vo alice -dn "$dn" query-proxy-filename`

    if [ $? -eq 0 ] 
    then
      exec env X509_USER_PROXY=$proxy $ALIEN_ROOT/bin/alien $*
    else
      echo "Error setting proxy" 1>&2
      exit 3
    fi
}

#############################################################################
amonCtrl() {
#############################################################################
    unset PERL5LIB
    unset LD_LIBRARY_PATH
    unset DYLD_LIBRARY_PATH
    unset ALIEN_VERSION
    case $1 in
      start*|Start*)
        action=Start; shift 
        ;;
      stop*|Stop*)
         action=Stop; shift
        ;;
      *)
      echo "Unsupported control option: $1"
      exit 1
    esac
       
    if [ "x$1" = "x" ]
    then
      echo "Service name not specified."
      exit 1
    fi

    name=$1; shift

    export ALIEN_PROCESSNAME=$name

    case $ALIEN_LCG in 
       1|true|True|TRUE)
          amonLCG $action$name $* >> /tmp/m.log 2>&1
          ;;
       *)
          exec $ALIEN_ROOT/bin/alien $action$name $* >> /tmp/m.log 2>&1
          ;;
    esac
}

#############################################################################
amonMonit() {
#############################################################################
  $AMON_HOME/bin/monit -c $AMON_HOME/$HOSTNAME.monitrc $*
}

#############################################################################
reStart() {
#############################################################################

  echo "exec $*" > $AMON_HOME/restart
  chmod +x $AMON_HOME/restart
}

#############################################################################
reConfigure() {
#############################################################################

  echo "$* " > $AMON_HOME/reconfigure
  chmod +x $AMON_HOME/reconfigure
}

#############################################################################
amonAutoUpdate() {
#############################################################################

  rm -rf /tmp/amon.$$

  [ -x $AMON_HOME/reconfigure ] || return 

  [ -x $AMON_HOME/restart ] || return 
    
  wget $WGETOPTS -P /tmp/amon.$$ http://alien.cern.ch/amon || return
  chmod +x /tmp/amon.$$/amon || return
  mv $AMON $AMON.swp || return
  mv /tmp/amon.$$/amon $AMON
  $AMON_HOME/reconfigure
  if [ $? -ne 0 ] 
  then
     mv $AMON.swp $AMON
     return
  fi 
  rm -f $AMON.swp
  if [ -f $AMON_HOME/amon.pid ]
  then
    kill `cat $AMON_HOME/amon.pid` > /dev/null 2>&1
  fi
  exec $AMON_HOME/restart 
}

#############################################################################
die() {
#############################################################################
  echo $1
  exit 1
}

#############################################################################
amonInstall() {
#############################################################################

   if [ -f  $AMON_HOME/NoAutoInstall ]
   then
     die "Warning: This installation cannot be upgraded (file  $AMON_HOME/NoAutoInstall exists)."
   fi
 
   ALIEN_COMPONENTS=$(echo $ALIEN_COMPONENTS | sed 's/,/ /g')

   ALIEN_INSTALLER_HOME=${ALIEN_INSTALLER_HOME:=$HOME/.alien/cache}
  
   rm -rf $ALIEN_INSTALLER_HOME

   mkdir -p $ALIEN_INSTALLER_HOME 
   if [ $? -ne 0 ]
   then 
       die "Error: Cannot create $ALIEN_INSTALLER_HOME directory"
   fi

   cd $ALIEN_INSTALLER_HOME

   wget $WGETOPTS -P . $ALIEN_BITS_URL/$ALIEN_RELEASE/makefiles.tar.bz2  > /dev/null 2>&1

   if [ $? -ne 0 ]
   then 
       die "Error: Cannot fetch makefiles from  $ALIEN_BITS_URL/$ALIEN_RELEASE"
   fi

   tar jxf makefiles.tar.bz2 && rm makefiles.tar.bz2

   if [ -d $ALIEN_ROOT ]
   then 
     rm -rf $ALIEN_ROOT.bak
     mv $ALIEN_ROOT $ALIEN_ROOT.bak || exit 1
   fi

   mkdir -p $ALIEN_ROOT || exit 1

   (
   ./configure --with-alien-release=$ALIEN_RELEASE  --with-platform=$ALIEN_PLATFORM --with-bits-url=$ALIEN_BITS_URL/$ALIEN_RELEASE/download/ --prefix=$ALIEN_ROOT || exit 1

   export GARAUTODETECT=0
   export TPUT=undef

   packages=""

   for meta in $ALIEN_COMPONENTS
   do
     pkgdir=`echo $meta | sed 's/"//g'`
     if [ "$pkgdir" = "" ]
     then
       continue
     fi
     if [ -d $ALIEN_INSTALLER_HOME/meta/$pkgdir ]
     then
       echo "Evaluating dependencies for $meta. Please wait...." 
       list=`cd $ALIEN_INSTALLER_HOME/meta/$pkgdir; make show-unique-deps`
       for pkg in $list
       do
         echo $packages | grep "$pkg," > /dev/null 2>&1 || packages=$packages","$pkg
       done
     fi
   done

   packages=`echo $packages | sed 's/,/ /g'`
 
   npkgs=`echo $packages | wc -w`
   i=0

   for pkg in $packages
   do
     p=$[$[i * 100]/$[npkgs + 1]];
     i=$[i + 1]
     printf "[%3d%%] Installing: %s\n" $p $pkg
     if [ ! -d $pkg ]
     then
        echo "No such package: $dir"
     fi
     make -s -C $pkg bininstall LIBDEPS= BUILDDEPS= > /dev/null || exit 1
   done

   if [ -f $ALIEN_INSTALLER_HOME/ALIEN_VERSION ]
   then
     cp -f $ALIEN_INSTALLER_HOME/ALIEN_VERSION $ALIEN_ROOT/share/alien
   fi

   rm -rf $ALIEN_INSTALLER_HOME

   ) ||  ( 
     rm -rf $ALIEN_ROOT
     if [ -d  $ALIEN_ROOT.bak ]
     then
       mv $ALIEN_ROOT.bak $ALIEN_ROOT 
     fi
   )

  if [  x$AMON_HOME != "x" -a x$AMON != "x" ]
  then
    if [ -x $AMON_HOME/reconfigure -a \
         -x $AMON_HOME/restart -a \
         -x $AMON -a \
         -x amon ]
    then
      rm -f $AMON.swp
      mv $AMON $AMON.swp
      mv amon $AMON
      $AMON_HOME/reconfigure
      if [ $? -ne 0 ]
      then
        mv $AMON.swp $AMON
      else
        rm -f $AMON.swp
        if [ -f $AMON_HOME/amon.pid ]
        then
          kill `cat $AMON_HOME/amon.pid` > /dev/null 2>&1
        fi
      fi
    fi
  fi
}

#############################################################################
amonUsage() {
#############################################################################

 printf "Usage: amon [--debug]                          \n"
 printf "            [--alien-organisation <org>]       \n"
 printf "            [--alien-root <dir>]               \n"
 printf "            [--alien-components <site,monitor,..>]\n"
 printf "            [--alien-services <CE,SE,...>]     \n"
 printf "            [--logdir <dir>]                   \n"
 printf "            [--cs-logdir <dir>]                \n"
 printf "            [--bits-url <url>]  configure      \n"
 printf "\n"
 printf "       amon [--debug] --ctrl <Start|Stop> <service>\n"
 printf "\n"
 printf "       amon [--debug] --monit                  \n"
 printf "\n"
 printf "       amon [-debug]                           \n"
 printf "            [--alien-release <release>]        \n"
 printf "            install                            \n"
 printf "\n"
 printf "       amon --master                           \n"
 printf "            [--http_server <server>]           \n"
 printf "            [--http_port <port>]               \n"
 printf "            [--trace]                          \n"
 printf "\n"
 printf "       amon [--server <server>]                \n"
 printf "            [--port <port>]                    \n"
 printf "            [--trace]                          \n"
 exit
}

#############################################################################
#############################################################################
   
    configEnv

    args=$*

    while [ $# -gt 0 ]
    do
        case $1 in
            --debug)
                shift 1
                set -vx
                ;;
            --alien-organisation)
                shift 1
                export ALIEN_ORGANISATION=$1
                shift 1
                ;;
            --alien-root)
                shift 1
                export ALIEN_ROOT=$1
                shift 1
                ;;
            --alien-components)
                shift 1
                export ALIEN_COMPONENTS=$(echo $1 | sed 's/,/ /g')
                shift 1
                ;;
            --alien-services)
                shift 1
                export ALIEN_SERVICES=$(echo $1 | sed 's/,/ /g')
                shift 1
                ;;
            --notify)
                shift 1
                ALIEN_NOTIFY_EMAIL=$1
                shift 1
              ;;
            --logdir)
                shift 1
                ALIEN_LOGDIR=$1
                shift 1
              ;;
            --cs-logdir)
                shift 1
                ALIEN_CS_LOGDIR=$1
                shift 1
              ;;
            --bits-url)
                shift 1
                ALIEN_BITS_URL=$1
                shift 1
              ;;
            --alien-release)
                shift 1
                ALIEN_RELEASE=$1
                shift 1
              ;;
            --monit)
                shift 1
                amonMonit $*
                exit
              ;;
            --autoupdate)
                shift 1
                amonAutoUpdate
                exit
              ;;
            --ctrl)
                shift 1
                amonCtrl $*
                exit
              ;;
            configure)
                shift 1
                amonConfig
                reConfigure $AMON $args
                exit
              ;;
            token)
                shift 1
                configSiteToken
                exit
              ;;
            install)
                shift 1
                amonInstall $* 
                exit
              ;;
            rebuild)
                shift 1
                reBuildModules $* 
                exit
              ;;
            --help|-help|-h)
                amonUsage
              ;;
            *)
              break
              ;;
        esac
    done

    export AMON_LOGFILES=$LOGFILES  

    for file in $AMON_LOGFILES
    do
      dir=`dirname $file`
      mkdir -p $dir
      touch $file
    done
    
    reStart $AMON $args

    cd $AMON_HOME

#   exec $PERL -x -- $0 $* 
    exec $PERL -x -- $AMON $* 
 
#############################################################################
#!perl
#############################################################################
use warnings;
use strict;

$SIG{PIPE} = 'IGNORE';    # otherwise, SIGPIPE terminates the proxy.

use Filter::Template;     #this is only a shortcut

const XNode POE::Filter::XML::Node

use POE;
use POE::Component::Server::TCP;
use POE::Component::Server::PreforkTCP;
use POE::Component::Client::TCP;
use POE::Component::Client::HTTP;
use POE::Filter::HTTPD;
use POE::Filter::Stream;
use HTTP::Response;
use HTTP::Request;
use Socket;
use Getopt::Long;
#use XML::Simple;

use Net::LDAP;
use Net::DNS;

use Storable qw(freeze thaw);

use POE::Component::Jabber;                   #include PCJ
use POE::Component::Jabber::Error;            #include error constants
use POE::Component::Jabber::Status;           #include status constants
use POE::Component::Jabber::ProtocolFactory;  #include connection type constants
use POE::Filter::XML::Node;                   #include to build nodes
use POE::Filter::XML::NS qw/ :JABBER :IQ /;   #include namespace constants
use POE::Filter::XML::Utils;

use Cache::Memcached;  
use MIME::Base64;

my $AMON_HTTP_SERVER = "localhost";
my $AMON_HTTP_PORT   = 8000;
my $AMON_SERVER      = `hostname`; chomp($AMON_SERVER);
my $AMON_PORT         = 8001;
my $AMON_CACHE_SERVER = "localhost";
my $AMON_CACHE_PORT   = 8003;
my $AMON_AUTHZ_TOKEN  = $ENV{ALIEN_UUID};

my $MEMD = new Cache::Memcached {
    'servers'            => ["$AMON_CACHE_SERVER:$AMON_CACHE_PORT"],
    'debug'              => 0,
    'compress_threshold' => 10_000,
};

# use Config::ApacheFormat;

use Log::TraceMessages qw(t d);

$Log::TraceMessages::On = 0;

my $MONIT_PORT = 2812;

my $AUTHORIZED_HOSTS = {
      "sites" => { "CERN" => ["pcalijabber1.cern.ch",
                              "pcalicepb.cern.ch",
                              "alien.cern.ch",
                              "pcalienx.cern.ch"]
                 }
};


my %SITE;

my $LogToName = {
    "ProxyServer"          => "Proxy",
    "Manager::Transfer"    => "TransferManager",
    "Manager::Job"         => "Server",
    "Broker::Job"          => "Broker",
    "Broker::Transfer"     => "TransferBroker",
    "Optimizer::Transfer"  => "TransferOptimizer",
    "Optimizer::Job"       => "JobOptimizer",
    "Optimizer::Catalogue" => "CatalogueOptimizer",
    "ClusterMonitor"       => "Monitor",
};

my $MASTER_ID  = $ENV{MASTER_ID} ;       
my $MASTER_KEY = $ENV{MASTER_KEY};       
my $UID        = $ENV{SITE_ID};          
my $UKEY       = $ENV{SITE_KEY};         
my $REALM      = $ENV{ALIEN_SITE_REALM}; 

my $COMPONENT = 'JabberServer';

#############################################################################
sub logevent {
#############################################################################

    my ( $state, $arg ) = @_;
    t "####################################################################";
    t "$state: ";
    defined($arg) && t d($arg);
    t "####################################################################";
}

#############################################################################
sub getConfig {
#############################################################################

    my $organisation = "Alice";
    my $LdapDN       = "aliendb06a.cern.ch:8389/o=alice,dc=cern,dc=ch";

    my ( $ldaphost, $base ) = split( '/', $LdapDN );
    my $ldap = Net::LDAP->new($ldaphost) or die "$@";
    $ldap->bind();

    my $result = $ldap->search(
        base   => "ou=Sites,$base",
        scope  => "sub",
        filter => "(host=*)",
        attrs  => ['host'],
    );

    my @entries = $result->entries;
    my @hosts;
    my $entry;
    my $site;
    my $host;

    foreach $entry (@entries) {
      my @object = split( /,/, $entry->asn->{objectName} );
        if (   $object[2] eq "ou=Services"
            or $object[2] eq "ou=services" ){
            shift @object;
        }

      my @val  = split( /=/, $object[2] );
      $site = $val[1];
      $host = $entry->get_value("host");
      if ( $site ne "Sites" ) {
        if (!defined($AUTHORIZED_HOSTS->{sites}->{$site})) {
          push @{$AUTHORIZED_HOSTS->{sites}->{$site}}, $host;
        } else {
          if ( ! grep {/$host/} @{$AUTHORIZED_HOSTS->{sites}->{$site}}) {
              push @{$AUTHORIZED_HOSTS->{sites}->{$site}}, $host;
          }
        }
      }
    }


    my $res = Net::DNS::Resolver->new;

    foreach $site ( keys %{$AUTHORIZED_HOSTS->{sites}} ) {
      foreach $host ( @{$AUTHORIZED_HOSTS->{sites}->{$site}}) {
        $AUTHORIZED_HOSTS->{hosts}->{$host}->{session} = 0;
        $AUTHORIZED_HOSTS->{hosts}->{$host}->{port} = $MONIT_PORT;
        my $query = $res->search("$host");
        if ($query) {
              my $r;
              foreach ($query->answer) {
                 next unless $_->type eq "A";
                 $r = $_;
              }
              $AUTHORIZED_HOSTS->{dns}->{$r->address} = $host;
        }
      }
    }
    $MEMD->set( "AUTHORIZED_HOSTS", $AUTHORIZED_HOSTS );
}

#############################################################################
sub pcjStatus {
#############################################################################

    # The status event receives all of the various bits of status from PCJ. PCJ
    # sends out numerous statuses to inform the consumer of events of what it is
    # currently doing (ie. connecting, negotiating TLS or SASL, etc). A list of
    # these events can be found in PCJ::Status.

    my ( $kernel, $sender, $heap, $state ) =  @_[ KERNEL, SENDER, HEAP, ARG0 ];
    if ( $state == +PCJ_INIT_FINISHED ) {
          my $jid = $heap->{$COMPONENT}->jid();
          $heap->{'jid'} = $jid;
          $heap->{'sid'} = $sender->ID();
          $kernel->post( $COMPONENT, 'output_handler',XNode->new('presence') );

          # And here is the purge_queue. This is to make sure we haven't sent
          # nodes while something catastrophic has happened (like reconnecting).

          $kernel->post( $COMPONENT, 'purge_queue' );
    }
}

 # This is the error event. Any error conditions that arise from any point
 # during connection or negotiation to any time during normal operation will be
 # send to this event from PCJ. For a list of possible error events and exported
 # constants, please see PCJ::Error

#############################################################################
sub pcjError {
#############################################################################
     my ( $kernel, $sender, $heap, $error ) = @_[ KERNEL, SENDER, HEAP, ARG0 ];
     if ( $error == +PCJ_SOCKETFAIL ) {
                    my ( $call, $code, $err ) = @_[ ARG1 .. ARG3 ];
                    print "Socket error: $call, $code, $err\n";
                    $kernel->delay( 'reconnect', 1);
                }
                elsif ( $error == +PCJ_SOCKETDISCONNECT ) {
                    print "We got disconneted\n";
                    $kernel->delay( 'reconnect', 10);
                }
                elsif ( $error == +PCJ_CONNECTFAIL ) {
                    print "Connect failed\n";
                    $kernel->delay( 'reconnect', 1);
                }
                elsif ( $error == +PCJ_SSLFAIL ) {
                    print "TLS/SSL negotiation failed\n";
                }
                elsif ( $error == +PCJ_AUTHFAIL ) {
                    print "Failed to authenticate\n";
                }
                elsif ( $error == +PCJ_BINDFAIL ) {
                    print "Failed to bind a resource\n";
                }
                elsif ( $error == +PCJ_SESSIONFAIL ) {
                    print "Failed to establish a session\n";
     }
}

#############################################################################
sub  pcjOutput {
#############################################################################

    # This is our own output_event that is a simple passthrough on the way to
    # post()ing to PCJ's output_handler so it can then send the Node on to the
    # server
    my ( $kernel, $heap, $node, $sid ) =  @_[ KERNEL, HEAP, ARG0, ARG1 ];
    t d($node);
    $kernel->post( $sid, 'output_handler', $node );
}

#############################################################################
sub createJabberServer {
#############################################################################

    use DJabberd;
    use DJabberd::Delivery::Local;
    use DJabberd::PresenceChecker::Local;
    use DJabberd::RosterStorage::SQLite;

    &getConfig;

    $0 = "djabberd";

    for my $key ('MASTER_AUTHORIZATION_KEY') {
      defined ($ENV{$key})  or die("ERROR: Please define $key  in $ENV{AMON_HOME}/key.conf file");
    }

    my $rs = DJabberd::RosterStorage::SQLite->new;
    $rs->set_config_database("$ENV{AMON_HOME}/etc/djabberd/jabber.sqlite");
    $rs->finalize;

    my $token = DJabberd::Authen::MySiteToken->new;

    $token->set_config_realm($ENV{ALIEN_SITE_REALM});

    $token->set_config_key($ENV{MASTER_AUTHORIZATION_KEY});

    $token->finalize;

    my $vhost = DJabberd::VHost->new(
                                 server_name => $ENV{ALIEN_SITE_REALM},
                                 require_ssl => 1,
                                 s2s         => 0,
                                 plugins   => [
                                               $token,
                                               $rs,
                                               DJabberd::Delivery::Local->new,
                                               ],
                                 );

    my $update_cache = sub {
      my $connection = shift;
      my $socks =  $connection->{'jid2sock'};

      foreach my $site ( keys %{$AUTHORIZED_HOSTS->{sites}} ) {
         foreach my $host ( @{$AUTHORIZED_HOSTS->{sites}->{$site}}) {
            $AUTHORIZED_HOSTS->{hosts}->{$host}->{"session"} = undef ;
        }
      }
      for my $socket (keys %$socks) {
        my $peer_jid  = $socks->{$socket}->{bound_jid}->as_bare_string();
        my $master_jid = "$MASTER_ID".'@'.$REALM;
        if ( $peer_jid ne $master_jid ) {
          my $peer_ip   = $socks->{$socket}->{peer_ip};
          if ( defined($AUTHORIZED_HOSTS->{dns}->{$peer_ip}) ) {
            $AUTHORIZED_HOSTS->{hosts}->{$AUTHORIZED_HOSTS->{dns}->{$peer_ip}}->{"session"} = $peer_jid;
          }
        }
      }
      $MEMD->set( "AUTHORIZED_HOSTS", $AUTHORIZED_HOSTS );
    };

    $vhost->register_hook("ConnectionClosing",$update_cache);
    $vhost->register_hook("OnInitialPresence",$update_cache);

    my $server = DJabberd->new(
                           daemonize => 0,
                           );

    $server->set_config_sslcertificatefile("$ENV{AMON_HOME}/etc/djabberd/server-cert.pem");
    $server->set_config_sslcertificatekeyfile("$ENV{AMON_HOME}/etc/djabberd/server-key.pem");
    $server->set_config_oldssl(0);
    $server->set_config_clientport($AMON_PORT);
    $server->set_config_pidfile("$ENV{AMON_HOME}/etc/djabberd.pid");
    $server->add_vhost($vhost);
    $server->run;
}


#############################################################################
sub createServer {
#############################################################################

    for my $key ('MASTER_ID','MASTER_KEY') {
      defined ($ENV{$key})  or die("ERROR: Please define $key  in $ENV{AMON_HOME}/key.conf file");
    }
    # Create jabber server
   
    POE::Session->create(
        inline_states => {
            _start => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                $kernel->alias_set("jabber");
            },
            _stop  => sub { },
            stdout => sub {
                my ( $kernel, $heap, $self, $args ) = @_[ KERNEL, HEAP, ARG0 .. $#_ ];
                push( @{$heap->{output} }, $args->{out});
                ( @{ $heap->{output} } > 1000 ) && shift @{ $heap->{output} };
            },
            stderr => sub {
                my ( $kernel, $heap, $self, $args ) = @_[ KERNEL, HEAP, ARG0 .. $#_ ];
                push( @{$heap->{output} }, $args->{out});
                ( @{ $heap->{output} } > 1000 ) && shift @{ $heap->{output} };
            },
            done => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
            },
            died => sub {
                my ( $kernel, $heap, $self, $args ) = @_[ KERNEL, HEAP, ARG0 .. $#_ ];
                print join("", @{$heap->{output}});
            },
            error => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
            },
       },
    );

    my $jabber = POE::Component::Child->new( alias => "jabber", );

    $jabber->{StdioFilter} = POE::Filter::Line->new( OutputLiteral => '\n' );

    $jabber->run("$ENV{AMON}", "--jabber");

    # First we create our own session within POE to interact with PCJ
    my $server = POE::Session->create(
        options       => { debug => 0, trace => 0 },
        inline_states => {
            _start => sub {
                my ( $kernel, $heap ) = @_[ KERNEL, HEAP ];
                $kernel->alias_set('Jabber');
                $heap->{$COMPONENT} = POE::Component::Jabber->new(
                    IP             => $AMON_SERVER,
                    Port           => $AMON_PORT,
                    Hostname       => $REALM,
                    Username       => "$MASTER_ID",
                    Password       => "$MASTER_KEY",
                    Alias          => $COMPONENT,
                    ConnectionType => +LEGACY,
                    Debug          => '0',
                    States         => {
                        StatusEvent => "StatusEvent",
                        InputEvent  => "InputEvent",
                        ErrorEvent  => "ErrorEvent",
                    }
                );
                $kernel->delay( 'reconnect', 5);
            },

            _stop => sub {
                my $kernel = $_[KERNEL];
                $kernel->alias_remove();
                my $pidfile = "$ENV{AMON_HOME}/etc/djabberd.pid";
                open F, "$pidfile" or die "Can't open $pidfile : $!";
                my $pid = <F>; chomp $pid;
                close F;
                kill 1, $pid;                
            },

            StatusEvent => \&pcjStatus,
            ErrorEvent  => \&pcjError,
            OutputEvent => \&pcjOutput,

            InputEvent => sub {

     # This is the input event. We receive all data from the server through this
     # event. ARG0 will a POE::Filter::XML::Node object.

                my ( $kernel, $heap, $node ) = @_[ KERNEL, HEAP, ARG0 ];

                my $msg = $node->attr('msg');

                foreach ($msg) {
                    /REPLY/ && do {
                        my $sid  = $node->attr('sid');
                        my $body = decode_base64($node->get_tag('body')->data());
                        $kernel->post($sid => "got_response", $body);
                        last;
                    };
                    /INFO/ && do {
                        my $hostname = $node->attr('hostname');
                        my $input = decode_base64($node->get_tag('body')->data());
                        my $status = thaw ($input);
                        $MEMD->set( "stat_".$hostname, $status );
                        last;
                    };
                }
            },

           ClientInput => sub {
               my ( $kernel, $session, $heap, $input ) = @_[ KERNEL, SESSION, HEAP, ARG0 ];
               logevent('info server got input');
            },

            reconnect => sub {
                my ( $kernel, $heap ) = @_[ KERNEL, HEAP ];
                $kernel->post($COMPONENT,'reconnect');
            },

            request => sub {
                my ( $kernel, $heap, $reply, $input, $hostname, $jid ) = @_[ KERNEL, HEAP, ARG0, ARG1, ARG2, ARG3 ];
                logevent("http request accepted by proxy");
                my $node = XNode->new('message');
                $node->attr( 'from', get_bare_jid( $heap->{'jid'} ) );
                $node->attr('to',$jid); 
                $node->attr( 'sid', $reply );
                $node->insert_tag('body')->data( $input );
                $kernel->yield( 'OutputEvent', $node, $heap->{'sid'} );
            },
        }
    );

    my $http = POE::Component::Server::TCP->new(
        Alias        => "http_server",
        Hostname     => $AMON_HTTP_SERVER,
        Port         => $AMON_HTTP_PORT,
        ClientFilter => 'POE::Filter::HTTPD',

        ClientInput => sub {
            my ( $kernel, $session, $heap, $input ) =  @_[ KERNEL, SESSION, HEAP, ARG0 ];
            logevent('http server got input');
            my $uri = $input->uri;
            my @path = split( "/", $uri );
            my $response;
            if ( @path > 2 ) {
                shift @path;
                my $rhost = shift @path;
                my $rport = shift @path;

                $AUTHORIZED_HOSTS = $MEMD->get("AUTHORIZED_HOSTS");

                my $jid =  $AUTHORIZED_HOSTS->{hosts}->{$rhost}->{"session"};

                if ( defined ($jid) ) {
                    $heap->{rhost} = $rhost;
                    $heap->{rport} = $rport;
                    $input->header( "extrapath", "$rhost:$rport" );
                    $uri = "http://localhost:$rport/" . join( "/", @path );
                    $input->uri($uri);
                    logevent("http server forwarding request to $heap->{rhost}", $uri );
                    $kernel->post( $server => "request", $session->ID, $input->as_string(), $rhost, $jid );
                }
                else {
                    logevent("Client not connected");
                    $response = HTTP::Response->new( 404,"ERROR: Client not connected." );
                    $heap->{client}->put($response);
                    $kernel->yield("shutdown");
                }
            }
            else {
                logevent("Misformed URL");
                $response = HTTP::Response->new( 404, "ERROR: Misformed URL." );
                $heap->{client}->put($response);
                $kernel->yield("shutdown");
            }
        },

        ClientDisconnected => sub {
            my ( $kernel, $session, $heap ) = @_[ KERNEL, SESSION, HEAP ];
            logevent('http server got disconnect');
        },

        ClientError => sub {
            my ( $kernel, $session, $heap ) = @_[ KERNEL, SESSION, HEAP ];
            $kernel->yield("shutdown");
        },

        # InlineStates let us attach our own events and handlers to a TCP
        # server.  Here we attach a handler for the got_response event, which
        # will be sent to us by proxy server when it has recieved reply from
        # remote server.

        InlineStates => {
            got_response => sub {
                my ( $kernel, $heap, $input ) = @_[ KERNEL, HEAP, ARG0 ];
                logevent('http server got response');
                my $response = HTTP::Response->parse($input);
                $heap->{client}->put($response) if defined( $heap->{client} );
                $kernel->yield("shutdown");
            },
        },
    );


}

#############################################################################
sub createAgent {
#############################################################################
    use POE qw(Wheel::FollowTail Wheel::Run Filter::Line Component::Child);

    system(
        "$ENV{AMON_HOME}/bin/monit",              "-c",
        "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "quit"
    );
    sleep(1);
    system( "$ENV{AMON_HOME}/bin/monit", "-c",
        "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc" );
    sleep(1);
    system(
        "$ENV{AMON_HOME}/bin/monit",              "-c",
        "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "monitor",
        "all"
    );

    my $AMON          = $ENV{AMON};
    my $ALIEN_RELEASE = $ENV{ALIEN_RELEASE};
    my @ALIEN_COMPONENTS =
      split( " ",
        defined( $ENV{ALIEN_COMPONENTS} ) ? $ENV{ALIEN_COMPONENTS} : "" );

    my @ALIEN_SERVICES =
      split( " ", defined( $ENV{ALIEN_SERVICES} ) ? $ENV{ALIEN_SERVICES} : "" );
    my @ALIEN_INSTALLED_SERVICES = split(
        " ",
        defined( $ENV{ALIEN_INSTALLED_SERVICES} )
        ? $ENV{ALIEN_INSTALLED_SERVICES}
        : ""
    );

    my $INSTALLER_STATUS = "Idle";

    my $has_logfile;
    my $saved_status = "";
    my $saved_key    = "";

    POE::Component::Client::HTTP->spawn(
        Alias   => 'ua',
        Timeout => 180,
    );

    POE::Session->create(
        inline_states => {
            _start => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                $kernel->alias_set("installer");
            },
            _stop  => sub { },
            stdout => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                my $stdout = $args->{out};
                logevent("Agent got stdout: $stdout");
                $kernel->post(
                    Jabber => "installer_response",
                    "$stdout"
                );
            },
            stderr => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                my $stderr = $args->{out};
                logevent("Agent got stderr: $stderr");
                $kernel->post(
                    Jabber => "installer_response",
                    "$stderr"
                );
            },
            done => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                logevent("Agent got done");
                $kernel->post( Jabber => "installer_done" );
            },
            died => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                logevent("Agent got done");
                $kernel->post(
                    Jabber => "installer_status",
                    "Died"
                );
            },
            error => sub {
                my ( $kernel, $self, $args ) = @_[ KERNEL, ARG0 .. $#_ ];
                logevent("Agent got done");
                my $error = $args->{error};
                $kernel->post(
                    Jabber => "installer_status",
                    "Error: $error"
                );
            },
        }
    );

    my $installer = POE::Component::Child->new( alias => "installer", );

    $installer->{StdioFilter} = POE::Filter::Line->new( OutputLiteral => '\n' );

    POE::Session->create(
        options       => { debug => 0, trace => 0 },
        inline_states => {
            _start => sub {
                my ( $kernel, $heap ) = @_[ KERNEL, HEAP ];
                for my $filename ( split( / /, $ENV{AMON_LOGFILES} ) ) {
                    next if $filename eq "";
                    my @path = split( "/", $filename );
                    my $logname = pop @path;
                    $logname =~ s%\.log%%;
                    my $name =
                      defined( $LogToName->{$logname} )
                      ? $LogToName->{$logname}
                      : $logname;
                    $heap->{$name}->{logfile} = $filename;
                    $has_logfile->{$name} = 1;
                }
                $kernel->alias_set('Jabber');
                $heap->{$COMPONENT} = POE::Component::Jabber->new(
                    IP             => $AMON_SERVER,
                    Port           => $AMON_PORT,
                    Hostname       => $REALM,
                    Username       => "$UID",
                    Password       => "$UKEY",
                    Alias          => $COMPONENT,
                    ConnectionType => +LEGACY,
                    Debug          => '0',
                    States         => {
                        StatusEvent => "StatusEvent",
                        InputEvent  => "InputEvent",
                        ErrorEvent  => "ErrorEvent",
                    }
                );
                $kernel->delay( 'reconnect', 1);
            },

            _stop => sub {
                my $kernel = $_[KERNEL];
                $kernel->alias_remove();
            },

            StatusEvent => sub {        
               my ( $kernel, $sender, $heap, $state ) =  @_[ KERNEL, SENDER, HEAP, ARG0 ];
               if ( $state == +PCJ_INIT_FINISHED ) {
                  my $jid = $heap->{$COMPONENT}->jid();
                  $heap->{'jid'} = $jid;
                  $heap->{'sid'} = $sender->ID();
                  $kernel->post( $COMPONENT, 'output_handler',XNode->new('presence') );
                  # And here is the purge_queue. This is to make sure we haven't sent
                  # nodes while something catastrophic has happened (like reconnecting).
                  $kernel->yield( $COMPONENT, 'purge_queue' );
                  $kernel->yield( 'get_status' );
               }
            },

            ErrorEvent  => \&pcjError,
            OutputEvent => \&pcjOutput,

            InputEvent => sub {
#
# This is the input event. We receive all data from the server through this
# event. ARG0 will a POE::Filter::XML::Node object.
#
                my ( $kernel, $heap, $node ) = @_[ KERNEL, HEAP, ARG0 ];

                my $from = $node->attr('from');
                my $sid  = $node->attr('sid');
                my $input = $node->get_tag('body')->data();

                my $r = HTTP::Request->parse($input);
                $heap->{extrapath} = $r->header("extrapath");
                $heap->{extrasid} = $sid;
                $heap->{extrafrom} = $from;
                $heap->{uri}       = $r->uri;
                my @path = split( '/', $r->uri );
                my $mode = pop @path;
                my $page = pop @path;
                for ($page) {
                    /logs/ && do {
                           logevent("Agent got request for log files: $mode");
                           my $response = HTTP::Response->new( 200, "OK" );
                           $response->header( "content-type", "text/html" );
                           my @log;
                           open( LOG, "tail -1000 $heap->{$mode}->{logfile}|" )
                           and @log = <LOG>
                           and close LOG;
                           my $content = qq{<pre>};
                           $content .= join( "", @log );
                           $content .= qq{</pre></html>};
                           $response->content($content);
                           my $node = XNode->new('message');
                           $node->attr( 'to', $from );
                           $node->attr( 'sid', $sid );
                           $node->attr('msg','REPLY');
                           $node->insert_tag('body')->data(encode_base64($response->as_string()));
                           $kernel->yield( 'OutputEvent', $node, $heap->{'sid'} );
                           last;
                        };
                    /installer/ && do {
                        logevent("Agent sending message to installer: $mode");
                        if ( $mode eq "_done" ) {
                            $INSTALLER_STATUS = "Idle";
                            &installerStatus($kernel,$INSTALLER_STATUS,
                                             $from,$sid,$heap->{'sid'});
                            delete $heap->{installer};
                            last;
                        }
                        if ( $mode eq "_amon" ) {
                            if ( !defined( $heap->{installer} ) ) {
                               &installerStatus($kernel,"Autoupdate",
                                                $from,$sid,$heap->{'sid'});
                                exec( $AMON, "--autoupdate" )
   				      or warn("Could not autoupdate!");
                            }
                            last;
                        }
                        if ( $mode eq "_stop" ) {
                            if ( defined($installer) ) {
                                eval { $installer->kill( HARD => 1 ); };
                            }
                            &installerStatus($kernel,"Killed",
                                              $from,$sid,$heap->{'sid'});
                            last;
                        }
                        if ( $mode eq "_output" ) {
                            my $output = defined( $heap->{output} ) ?
                                         join( "\n", @{ $heap->{output} } ) : "n/a";
                            &installerStatus($kernel,$output,
                                              $from,$sid,$heap->{'sid'});
                            last;
                        }
                        if ( !defined( $heap->{installer} ) ) {
                            $heap->{installer} = "Running";
                            $INSTALLER_STATUS = "Running";
                            $kernel->post(Jabber => "installer_response","BEGIN");
                            my $version = $mode;
                            t "============ calling installer run","\n";
                            $kernel->post( Jabber => "installer_run", $version );
                        }
                        &installerStatus($kernel,$heap->{installer},
                                         $from,$sid,$heap->{'sid'});
                         last;
                    };
                    if ( defined($AMON_AUTHZ_TOKEN) ) {
                        $r->authorization_basic( 'admin', $AMON_AUTHZ_TOKEN );
                    }
                    $kernel->post( ua => request => got_response => $r );
                }
            },

            installer_response => sub {
                my ( $kernel, $heap, $response ) = @_[ KERNEL, HEAP, ARG0 ];
                logevent("Agent got reply from installer: $response");
                delete $heap->{output} if $response eq "BEGIN";
                push( @{ $heap->{output} }, $response );
                ( @{ $heap->{output} } > 1000 ) && shift @{ $heap->{output} };
            },
             installer_run => sub {
                my ( $kernel, $heap, $session ) = @_[ KERNEL, HEAP, SESSION ];
                my $version = $_[ARG0];
                t "============ got installer run","\n";
                logevent("Agent running $AMON installer for version $version");
                $installer->run( $AMON, "--alien-release", $version,
                    "install" );
            },

            installer_done => sub {
                my ( $kernel, $heap, $session ) = @_[ KERNEL, HEAP, SESSION ];
                my $version = $_[ARG0];
                logevent("Installer done");
                system(
                    "$ENV{AMON_HOME}/bin/monit",              "-c",
                    "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "stop",
                    "all"
                );
                sleep(60);
                system(
                    "$ENV{AMON_HOME}/bin/monit",              "-c",
                    "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "reload"
                );
                sleep(5);
                system( "$ENV{AMON_HOME}/bin/monit", "-c",
                    "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc" );
                sleep(5);
                system(
                    "$ENV{AMON_HOME}/bin/monit",              "-c",
                    "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "monitor",
                    "all"
                );
                system(
                    "$ENV{AMON_HOME}/bin/monit",              "-c",
                    "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc", "validate"
                );
                $heap->{installer} = "Done";
                $INSTALLER_STATUS = "Done";
            },

            installer_status => sub {
                my ( $kernel, $heap, $session ) = @_[ KERNEL, HEAP, SESSION ];
                my $status = $_[ARG0];
                $heap->{installer} = $status;
                $INSTALLER_STATUS = $status;
            },

            get_status => sub {
              my ( $kernel, $heap ) = @_[ KERNEL, HEAP ];
              logevent("Agent connnected");
              my $r = HTTP::Request->new( GET => 'http://localhost:2812/_status' );
              if ( defined($AMON_AUTHZ_TOKEN) ) {
                  $r->authorization_basic( 'admin', $AMON_AUTHZ_TOKEN );
               }
               $kernel->post( ua => request => send_status => $r );
            },

            send_status => sub {
                my ( $kernel, $heap, $request, $response_packet ) =
                  @_[ KERNEL, HEAP, ARG0, ARG1 ];
                logevent('Agent sending status info');
                my $r = $response_packet->[0];
                if ( $r->code == 500 ) {
                    system( "$ENV{AMON_HOME}/bin/monit", "-c",
                        "$ENV{AMON_HOME}/$ENV{HOSTNAME}.monitrc" );
                }
                my $status = &parseStatus( $r->content );
                if ( -e "$ENV{AMON_HOME}/NoAutoInstall" ) {
                    $status->{installer}->{autoupdate} = 0;
                }
                else {
                    $status->{installer}->{autoupdate} = 1;
                }
                $status->{installer}->{status} = $INSTALLER_STATUS;
                $status->{alien}               = {};
                $status->{alien}               = {
                    root               => $ENV{ALIEN_ROOT},
                    components         => [@ALIEN_COMPONENTS],
                    services           => [@ALIEN_SERVICES],
                    installed_services => [@ALIEN_INSTALLED_SERVICES],
                    version => $status->{installer}->{status} eq "Running"
                    ? "Updating..."
                    : &alienVersion,
                    logdir => $ENV{ALIEN_LOGDIR}
                };
                foreach my $p ( keys %{ $status->{process} } ) {
                    defined($has_logfile)
                      and $status->{process}->{$p}->{has_logfile} =
                      $has_logfile->{$p};
                }
                my $str = freeze ($status);
                if ( $str ne $saved_status ) {
                        my $node = XNode->new('message');
                        $node->attr( 'to', "master\@$REALM" );
                        $node->attr('msg',"INFO");
                        my $hostname = `hostname -f`; chomp $hostname;
                        $node->attr('hostname',$hostname);
                        $node->insert_tag('body')->data(encode_base64($str));
                        $kernel->yield( 'OutputEvent', $node, $heap->{'sid'} );
                        $saved_status = $str;
                }
                else {
                    logevent('Nothing changed');
                }
                $kernel->delay( get_status => 15 );
            },

# We got response from http server. Send it to http client on the other end .

            got_response => sub {
                my ( $kernel, $heap, $request, $response_packet ) =
                  @_[ KERNEL, HEAP, ARG0, ARG1 ];
                my ( $host, $port ) = split( /:/, $heap->{extrapath} );
                logevent('Agent got response');
                my $r = $response_packet->[0];

                my $node = XNode->new('message');
                $node->attr('to', $heap->{extrafrom});
                $node->attr('sid',$heap->{extrasid});
                $node->attr('msg',"REPLY");
                $node->insert_tag('body')->data(encode_base64($r->as_string()));
                $kernel->yield( 'OutputEvent', $node, $heap->{'sid'} );
            },

            reconnect => sub {
                my ( $kernel, $heap ) = @_[ KERNEL, HEAP ];
                $kernel->post($COMPONENT,'reconnect');
            },
        }
    );
}

#############################################################################
sub reDirect {
#############################################################################
    my ( $r, $page ) = @_;
    my $organisation = $r->header("organisation");
    my $home         = $r->header("home");
    my $host         = $r->header("host");
    my $port         = $r->header("port");
    my $url          = "$home/$organisation/$page/$host/$port/&page=$page";
    my $response     = HTTP::Response->new( 302, "Moved" );
    $response->header( "Location", $url );
    return $response->as_string();
}

#############################################################################
sub installerStatus {
#############################################################################
    my ($kernel,$msg,$to,$session,$sid) = @_;
    t "msg=",d($msg);
    t "to=",d($to);
    t "session=",d($session);
    t "sid=",d($sid);
    my $response = HTTP::Response->new( 200, "OK" );
    $response->header( "content-type", "text/html" );
    my $content = qq {$msg};
    $response->content($content);
    my $node = XNode->new('message');
    $node->attr('to', $to);
    $node->attr('sid',$session);
    $node->attr('msg',"REPLY");
    $node->insert_tag('body')->data(encode_base64($response->as_string()));
    t d($node);
    $kernel->yield( 'OutputEvent', $node, $sid);
}

#############################################################################
sub alienVersion {
#############################################################################
    my $version = "n/a";

    open( INPUT, "$ENV{ALIEN_ROOT}/share/alien/ALIEN_VERSION" ) && do {
        my $line = <INPUT>;
        close INPUT;
        $line =~ s/,//g;
        $line =~ s/AliEn //g;
        $line =~ s/build//g;
        $line =~ s/ *://g;
        my ( $v, $b ) = split( / /, $line );
        $version = "$v-$b";
    };

    return $version;

}
#############################################################################
sub parseStatus {
#############################################################################
    my $content = shift;

    my $status;
    my $process;
    my $system;
    my $tag;
    my $file;
    my $tagname;

    $status->{monit} = {};

    $status->{process}->{amon}->{status} = "running";

    foreach ( split( /\n/, $content ) ) {
        $_ eq "" and next;
        /^The monit daemon .*:/ and do {
            my ( $dummy, $uptime ) = split( /:/, $_ );
            $status->{monit}->{uptime} = $uptime;
            next;
        };
        /^File/ and do {
            my ( $dummy, $name ) = split( /\'/, $_ );
            $file    = $name;
            $tag     = "file";
            $tagname = $name;
            next;
        };
        /^Process/ and do {
            my ( $dummy, $name ) = split( /\'/, $_ );
            $process = $name;
            $tag     = "process";
            $tagname = $name;
            next;
        };
        /^System/ and do {
            my ( $dummy, $name ) = split( /\'/, $_ );
            $process = $name;
            $tag     = "system";
            $tagname = $name;
            next;
        };
        /^ *status/ and do {
            my ( $dummy, $value ) = split( /status */, $_ );
            $status->{$tag}->{$tagname}->{status} = $value;
            next;
        };
        /^ *monitoring status/ and do {
            my ( $dummy, $value ) = split( /monitoring status */, $_ );
            $status->{$tag}->{$tagname}->{mon_status} = $value;
            next;
        };
        /^ *permission/ and do {
            my ( $dummy, $value ) = split( /permission */, $_ );
            $status->{$tag}->{$file}->{permission} = $value;
            next;
        };
        /^ *uid/ and do {
            my ( $dummy, $value ) = split( /uid */, $_ );
            $status->{$tag}->{$file}->{uid} = $value;
            next;
        };
        /^ *gid/ and do {
            my ( $dummy, $value ) = split( /gid */, $_ );
            $status->{$tag}->{$file}->{gid} = $value;
            next;
        };
        /^ *timestamp/ and do {
            my ( $dummy, $value ) = split( /timestamp */, $_ );
            $status->{$tag}->{$file}->{timestamp} = $value;
            next;
        };
        /^ *size/ and do {
            my ( $dummy, $value ) = split( /size */, $_ );
            $status->{$tag}->{$file}->{size} = $value;
            next;
        };
        /^ *pid/ and do {
            my ( $dummy, $value ) = split( /pid */, $_ );
            $status->{$tag}->{$process}->{pid} = $value;
            next;
        };
        /^ *parent pid/ and do {
            my ( $dummy, $value ) = split( /parent pid */, $_ );
            $status->{$tag}->{$process}->{parent_pid} = $value;
            next;
        };
        /^ *uptime/ and do {
            my ( $dummy, $value ) = split( /uptime */, $_ );
            $status->{$tag}->{$process}->{uptime} = $value;
            next;
        };
        /^ *childrens/ and do {
            my ( $dummy, $value ) = split( /childrens */, $_ );
            $status->{$tag}->{$process}->{childrens} = $value;
            next;
        };
        /^ *memory kilobytes total/ and do {
            my ( $dummy, $value ) = split( /memory kilobytes total */, $_ );
            $status->{$tag}->{$process}->{memory_total} = $value;
            next;
        };
        /^ *memory kilobytes/ and do {
            my ( $dummy, $value ) = split( /memory kilobytes */, $_ );
            $status->{$tag}->{$process}->{memory} = $value;
            next;
        };
        /^ *memory percent total/ and do {
            my ( $dummy, $value ) = split( /memory percent total */, $_ );
            $status->{$tag}->{$process}->{memory_percent_total} = $value;
            next;
        };
        /^ *memory percent/ and do {
            my ( $dummy, $value ) = split( /memory percent */, $_ );
            $status->{$tag}->{$process}->{memory_percent} = $value;
            next;
        };
        /^ *cpu percent total/ and do {
            my ( $dummy, $value ) = split( /cpu percent total */, $_ );
            $status->{$tag}->{$process}->{cpu_percent_total} = $value;
            next;
        };
        /^ *cpu percent/ and do {
            my ( $dummy, $value ) = split( /cpu percent */, $_ );
            $status->{$tag}->{$process}->{cpu_percent} = $value;
            next;
        };
        /^ *cpu data collected/ and do {
            my ( $dummy, $value ) = split( /data collected */, $_ );
            $status->{$tag}->{$process}->{data_collected} = $value;
            next;
        };
        /^ *load average/ and do {
            my ( $dummy, $value ) = split( /load average */, $_ );
            $status->{$tag}->{$process}->{load_average} = $value;
            next;
        };
        /^ *memory usage/ and do {
            my ( $dummy, $value ) = split( /memory usage */, $_ );
            $status->{$tag}->{$process}->{memory_usage} = $value;
            next;
        };
    }

    return $status;
}

#############################################################################
#############################################################################

Log::TraceMessages::check_argv();

my $pidfile = $ENV{AMON_HOME} . "/amon.pid";
open F, "> $pidfile" or die "Can't open $pidfile : $!";
print F $$;
close F;

my $AMON = $0; $0 = "amon";

my $is_master = 0;
my $is_jabber = 0;

GetOptions(
    'master'         => \$is_master,
    'jabber'         => \$is_jabber,
    'server=s'       => \$AMON_SERVER,
    'port=i'         => \$AMON_PORT,
    'cache_server=s' => \$AMON_CACHE_SERVER,
    'cache_port=i'   => \$AMON_CACHE_PORT,
    'http_server=s'  => \$AMON_HTTP_SERVER,
    'http_port=i'    => \$AMON_HTTP_PORT
);

if ( $is_jabber ) {  
    &createJabberServer();
    exit 0;
}

( $is_master ? &createServer() : &createAgent() );

# Run POE

POE::Kernel->run();

exit 0;

#############################################################################
package DJabberd::Authen::MySiteToken;
#############################################################################

use strict;
use base 'DJabberd::Authen';

use DJabberd::Log;

our $logger = DJabberd::Log->get_logger;

use Digest::HMAC_SHA1;

sub log {
    $logger;
}

sub set_config_key {
    my ($self, $key) = @_;
    $self->{key} = $key;
}

sub set_config_realm {
    my ($self, $realm) = @_;
    $self->{realm} = $realm;
}

sub finalize {
    my $self = shift;
}

sub can_retrieve_cleartext { 1 }

sub get_password {
    my ($self, $cb, %args) = @_;
    my $uid   = $args{username};
    my $digest = Digest::HMAC_SHA1->new($self->{key});
    $digest->add($uid.$self->{realm});
    my $password = $digest->b64digest;
    $cb->set($password);
}

sub check_cleartext {
    my ($self, $cb, %args) = @_;
    my $uid   = $args{username};
    if ($args{password} eq $self->{password}) {
        $cb->accept;
        return;
    }
    $cb->reject;
}

#############################################################################
package DB;
#############################################################################
no strict 'refs';
no utf8;

sub DB{};

sub sub {
    # localize CALL_DEPTH so that we don't need to decrement it after the sub
    # is called
    local $DB::CALL_DEPTH = $DB::CALL_DEPTH+1;
    #my @foo = @_;
    my $fileline = "";
    if (ref $DB::sub eq "CODE") {
        my @caller = caller;
        my $pkg = $caller[0];
        my $line = $caller[2];
        $fileline = " called from $pkg, line $line";
    }
    warn ("." x $DB::CALL_DEPTH . " ($DB::CALL_DEPTH) $DB::sub$fileline\n");

    # Call our subroutine. @_ gets passed on for us.
    # by calling it last, we don't need to worry about "wantarray", etc
    # by returning it like this, the caller's expectations are conveyed to
    # the called routine
    &{$DB::sub};
}

1;

